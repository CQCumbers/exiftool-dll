package Pod::Strip;

use warnings;
use strict;
use base 'Pod::Simple';

sub new {
  my $new = shift->SUPER::new(@_);
  $new->{_code_line}=0;
  $new->code_handler(sub {
    print {$_[2]{output_fh}} $_[0],"\n";
    return;
  });
  return $new;
}

package App::FatPacker;

use strict;
use warnings FATAL => 'all';
use 5.008001;
use Getopt::Long;
use Cwd qw(cwd);
use File::Find qw(find);
use File::Spec::Functions qw(
  catdir splitpath splitdir catpath rel2abs abs2rel
);
use File::Spec::Unix;
use File::Copy qw(copy);
use File::Path qw(mkpath rmtree);
use B qw(perlstring);

our $VERSION = '0.010008'; # v0.10.8

$VERSION = eval $VERSION;

sub call_parser {
  my $self = shift;
  my ($args, $options) = @_;

  local *ARGV = [ @{$args} ];
  $self->{option_parser}->getoptions(@$options);

  return [ @ARGV ];
}

sub lines_of {
  map +(chomp,$_)[1], do { local @ARGV = ($_[0]); <> };
}

sub stripspace {
  my ($text) = @_;
  $text =~ /^(\s+)/ && $text =~ s/^$1//mg;
  $text;
}

sub import {
  $_[1] && $_[1] eq '-run_script'
    and return shift->new->run_script;
}

sub new {
  bless {
    option_parser => Getopt::Long::Parser->new(
      config => [ qw(require_order pass_through bundling no_auto_abbrev) ]
    ),
  }, $_[0];
}

sub run_script {
  my ($self, $args) = @_;
  my @args = $args ? @$args : @ARGV;
  $self->script_command_file(\@args);
}

sub script_command_help {
  print "Try `perldoc fatpack` for how to use me\n";
}

sub script_command_file {
  my ($self, $args) = @_;
  my $file = shift @$args;
  print $self->fatpack_file($file);
}

sub fatpack_file {
  my ($self, $file) = @_;

  my $shebang = "";
  my $script = "";
  if ( defined $file and -r $file ) {
    ($shebang, $script) = $self->load_main_script($file);
  }

  my @dirs = $self->collect_dirs();
  my %files;
  $self->collect_files($_, \%files) for @dirs;

  return join "\n", $shebang, $self->fatpack_code(\%files), $script;
}

# This method can be overload in sub classes
# For example to skip POD
sub load_file {
  my ($self, $file) = @_;
  my $content = do {
    local (@ARGV, $/) = ($file);
    <>
  };

  my $parser = Pod::Strip->new;
  my $stripped;
  $parser->output_string(\$stripped);
  $parser->parse_string_document($content);
  close ARGV;
  return $stripped;
}

sub collect_dirs {
  my ($self) = @_;
  my $cwd = cwd;
  return grep -d, map rel2abs($_, $cwd), ('lib','fatlib');
}

sub collect_files {
  my ($self, $dir, $files) = @_;
  find(sub {
    return unless -f $_;
    !/\.(pm|pl)$/ and warn "File ${File::Find::name} isn't a .pm file - can't pack this -- if you hoped we were going to, things may not be what you expected later\n" and return;
    $files->{File::Spec::Unix->abs2rel($File::Find::name,$dir)} =
      $self->load_file($File::Find::name);
  }, $dir);
}

sub load_main_script {
  my ($self, $file) = @_;
  open my $fh, "<", $file or die("Can't read $file: $!");
  my $shebang = <$fh>;
  my $script = join "", <$fh>;
  close $fh;
  unless ( index($shebang, '#!') == 0 ) {
    $script = $shebang . $script;
    $shebang = "";
  }
  return ($shebang, $script);
}

sub fatpack_start {
  return stripspace <<'  END_START';
    # This chunk of stuff was generated by App::FatPacker. To find the original
    # file's code, look for the end of this BEGIN block or the string 'FATPACK'
    BEGIN {
    my %fatpacked;
  END_START
}

sub fatpack_end {
  return stripspace <<'  END_END';
    s/^  //mg for values %fatpacked;

    my $class = 'FatPacked::'.(0+\%fatpacked);
    *{"${class}::files"} = sub { keys %{$_[0]} };

    *{"${class}::INC"} = sub {
      if (my $fat = $_[0]{$_[1]}) {
        #print($_[1], "\n");
        return sub {
          $fat =~ /\G([^\n]*\n?)/g or return 0;
          $_ = $1;
          return 1;
        }
      }
      return;
    };

    unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE
  END_END
}

sub fatpack_code {
  my ($self, $files) = @_;
  my @segments = map {
    (my $stub = $_) =~ s/\.pm$//;
    my $name = uc join '_', split '/', $stub;
    my $data = $files->{$_}; $data =~ s/^/  /mg; $data =~ s/(?<!\n)\z/\n/;
    '$fatpacked{'.perlstring($_).qq!} = '#line '.(1+__LINE__).' "'.__FILE__."\\"\\n".<<'${name}';\n!
    .qq!${data}${name}\n!;
  } sort keys %$files;

  return join "\n", $self->fatpack_start, @segments, $self->fatpack_end;
}

App::FatPacker->new->run_script
